"""
Parse the OData $metadata XML and enumerate all entity sets, their properties,
and navigation properties. Outputs a Markdown summary to
odata_schema/odata_schema_summary.md.

Usage:
    uv run python parse_odata_metadata.py

Requires: odata_schema/odata_metadata.xml (generated by fetch_odata_metadata.py)
"""

import logging
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

import defusedxml.ElementTree as ET

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

METADATA_PATH = Path(__file__).parent / "odata_schema" / "odata_metadata.xml"
SUMMARY_PATH = Path(__file__).parent / "odata_schema" / "odata_schema_summary.md"

if not METADATA_PATH.exists():
    logging.error(f"Metadata file not found: {METADATA_PATH}")
    exit(1)


def get_namespace_map(root: Any) -> Dict[Optional[str], str]:
    ns_map: Dict[Optional[str], str] = {}
    for k, v in root.attrib.items():
        if k.startswith("xmlns:"):
            ns_map[k.split(":", 1)[1]] = v
        elif k == "xmlns":
            ns_map[None] = v
    return ns_map


def main():
    tree = ET.parse(METADATA_PATH)
    root = tree.getroot()
    # OData v3/2 namespaces (Epicor P21)
    edmx_ns = "http://schemas.microsoft.com/ado/2007/06/edmx"
    edm_ns = "http://schemas.microsoft.com/ado/2009/11/edm"

    entity_types: Dict[str, List[Dict[str, Any]]] = {}
    entity_sets: List[Dict[str, Any]] = []
    navigation_props: Dict[str, List[Dict[str, Any]]] = {}
    incomplete_entities: Set[str] = set()

    # Find all Schema elements (default namespace is edm_ns)
    for schema in root.findall(f".//{{{edmx_ns}}}DataServices/{{{edm_ns}}}Schema"):
        # EntityTypes
        for et in schema.findall(f"{{{edm_ns}}}EntityType"):
            et_name = et.attrib["Name"]
            props = []
            for p in et.findall(f"{{{edm_ns}}}Property"):
                name = p.attrib.get("Name")
                typ = p.attrib.get("Type", "")
                if not name:
                    logging.warning(
                        f"EntityType '{et_name}' has a property without a name. "
                        f"Skipping property."
                    )
                    continue
                props.append({"name": name, "type": typ})
            # If any property is missing a name, flag entity as incomplete
            if len(props) != len(et.findall(f"{{{edm_ns}}}Property")):
                incomplete_entities.add(et_name)
            # Navigation properties with name and target type
            navs = [
                {
                    "name": n.attrib.get("Name", ""),
                    "to": n.attrib.get("ToRole") or n.attrib.get("Type", ""),
                }
                for n in et.findall(f"{{{edm_ns}}}NavigationProperty")
            ]
            entity_types[et_name] = props
            navigation_props[et_name] = navs
        # EntitySets (look for EntityContainer/EntitySet)
        for cs in schema.findall(f"{{{edm_ns}}}EntityContainer"):
            for es in cs.findall(f"{{{edm_ns}}}EntitySet"):
                entity_sets.append(
                    {
                        "Name": es.attrib["Name"],
                        "EntityType": es.attrib["EntityType"].split(".")[-1],
                    }
                )

    # Write Markdown summary
    with open(SUMMARY_PATH, "w", encoding="utf-8") as f:
        f.write("# OData Schema Summary\n\n")
        f.write(f"Parsed from: `{METADATA_PATH.name}`\n\n")
        for es in entity_sets:
            et_name = es["EntityType"]
            f.write(f"## EntitySet: `{es['Name']}` (Type: `{et_name}`)\n\n")
            if et_name in incomplete_entities:
                f.write(
                    "⚠️ **Warning:** Some properties could not be parsed for this "
                    "entity.\n\n"
                )
            f.write("**Properties:**\n\n")
            for prop in entity_types.get(et_name, []):
                f.write(f"- `{prop['name']}` ({prop['type']})\n")
            navs = navigation_props.get(et_name, [])
            if navs:
                f.write("\n**Navigation Properties:**\n\n")
                for nav in navs:
                    f.write(f"- `{nav['name']}` (to: `{nav['to']}`)\n")
            f.write("\n---\n\n")
    logging.info(f"OData schema summary written to: {SUMMARY_PATH}")
    if incomplete_entities:
        logging.warning(
            f"Entities with incomplete property lists: {sorted(incomplete_entities)}"
        )

    # Write JSON summary for AI agent consumption
    import json

    json_summary = {
        "entitySets": [
            {
                "name": es["Name"],
                "entityType": es["EntityType"],
                "properties": entity_types.get(es["EntityType"], []),
                "navigationProperties": navigation_props.get(es["EntityType"], []),
                "incomplete": es["EntityType"] in incomplete_entities,
            }
            for es in entity_sets
        ]
    }
    json_path = SUMMARY_PATH.with_suffix(".json")
    with open(json_path, "w", encoding="utf-8") as jf:
        json.dump(json_summary, jf, indent=2)
    logging.info(f"OData schema JSON summary written to: {json_path}")
    if incomplete_entities:
        logging.warning(
            f"Entities with incomplete property lists (see JSON 'incomplete' flag): "
            f"{sorted(incomplete_entities)}"
        )


if __name__ == "__main__":
    main()
